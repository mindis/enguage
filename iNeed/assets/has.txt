# OBJECT MODEL: C=CLASS D=DERIVED B=BASE O=OBJECT M=MEMBER V=VALUE L=LINK
#===================
# - HAS
# can be: martin/car -> ../oef852r
#     or: martin/name = "martin wheatman".
#     or: martin/keys/location -> ../../kitchen
# = basic set/query has
# class set
     On "a C has a M.", think "can a C have a M?".
Then on "a C has a M.", reply "I know".
Then on "a C has a M.", if not, think "set value C M default!".
Then on "a C has a M.", reply "Ok".
Then on "a C has a M.", if not, reply "I can't attribute M to C".
        "a C has a M." implies "is C a class?"; if not, reply "C is not a class".
## class get
     On "can a C have a M?", think "a member C isa M exists?".
Then on "can a C have a M?", if not, reply "no".
Then on "can a C have a M?", reply "yes".
##### OBJECTs ######
# object possibility of ownership
     On "can O have a M?", think "get link O instanceof!".
Then on "can O have a M?", think "a member ... isa $m exists?".
Then on "can O have a M?", if not, reply "no".
Then on "can O have a M?", reply "yes".
        "can O have a M?" implies "is O an entity"; if not, reply "O is not an object".

# object actuality of ownership
     On "does O have a M?", think "member $o $m exists?".
#Then on "does O have a M?", if not, reply "i do not know". #-- default answer
Then on "does O have a M?", reply "yes".
        "does O have a M?" implies "can O have a M?"; if not, reply "no".
        "does O have a M?" implies "is O an entity"; if not, reply "i do not know of O".

### I have a car.      -- creates a component
### My car is red.     -- sets a value within than component
### My car is f209klg. -- names it

## - attribute values

# This could be "is martin's car pj5ozw?"
# has_a uses it as "is martin's car red?" 
# -- it implements "martin's car is silver." correctly
# -- being is silver a car? if so set martin's car to silver
# -- otherwise what member of car may be silver? --> colour
#    so set martin's car's colour to silver
##On "is X's M V?", think "member X M V exists?";, replying "no" or "yes".
# firstly, as above, 
     On "is X's M V?", think "member X M V exists?".
Then on "is X's M V?", reply "yes".
# this is the magic bit... c/f below, but we don't ahve to write some special conceptualisation!
Then on "is X's M V?", think "what is V?".
#
# in here -- what if V doesn't exist?
# -- return null and insert null to give "link martin car \0 f209klg exists?" ?
Then on "is X's M V?", think "link X M ... V exists?".
Then on "is X's M V?", reply  "yes".
Then on "is X's M V?", if not, reply "no".
# -- if not needs also to call "member X M ? V exists?", then "member set X/M ... V!"
# this therefore needs to be like the implementation in has_a
# the implementation of "x's m is v." needs to be in here.
# ontology needs to be isa -> has_a -> member(this file renamed!)
# this file (attribute) is underneath them all in language.jinx

## === entity valued attributes: "martin car is red" OR "martin's car is f209klg"
## can distinguish betw. red as (colour) value and f209klg as entity (car instance)
## need unnamed entity (component) for WAMK -- my keys are an unnamed entity
# uncomment these lines (and comment out first) when "is X's M V?" works consistently
     On "X's M is V.", think "is X's M V?".
Then on "X's M is V.", reply "i know".
Then on "X's M is V.", think "is V a M?".
Then on "X's M is V.", think "create a link called M between X and V".
Then on "X's M is V.", reply "ok".
Then on "X's M is V.", think "what is V?".
Then on "X's M is V.", if not, reply "I do not know what V is".
Then on "X's M is V.", think "the ... of X's M is V.".
Then on "X's M is V.", reply "ok".

######
# === dereferenced valued attributes... experimental
# martin's car's colour is X.
     On "M's N's O is P.", think "get link M N!".
Then on "M's N's O is P.", think "set link ... O P!".
Then on "M's N's O is P.", reply "ok".
        "M's N's O is P." implies "Does M have a N?"; if not, reply "M does not have a N".
        "M's N's O is P." implies "Can a N have a O?"; if not, reply "N can not have a O".
        "M's N's O is P." implies "is P a O?"; if not, reply "P is not a O".
# "The colour of martin's car is red."
On "the O of M's N is P.", think "M's N's O is P".
# "The colour of the car of martin is red."
On "the O of the N of M is P.", think "M's N's O is P".
####

## N.B> QUOTED doesn't quite work - appended patterns don't match already added one
## === string valued attributes impersonal then personal my/your
#     On "O's M is QUOTED-V.", think "set attribute O M V!".
#Then on "O's M is QUOTED-V.", if not, reply "Cannot set O's M".
#Then on "O's M is QUOTED-V.", reply "Ok".
#        "O's M is QUOTED-V." implies "Can O have a M?"; if not, reply "O cannot have a M".

## General value retrieval 1: "what is martin's car?"
## impersonal/pesonal what is X's Y?
     On "what is O's M?", think "get member O M!".
#Then on "what is O's M?", if not, reply "I do not know". # -- default answer!
Then on "what is O's M?", reply "O's M is ...".
        "what is O's M?" implies "Can O have a M?"; if not, reply "O does not have a M".



# General value retrieval 2: "what colour is your car?"
#On "what X is Z's Y?" perform "attribute get (link get $z $y) $x | link get (link get $z $y) $x"; on false, reply "i do not know" otherwise "Z's Y is ...".
     On "what X is Z's Y?", think "get link Z Y!".
Then on "what X is Z's Y?", think "get member ... X!".
Then on "what X is Z's Y?", reply "Z's Y is ...".
#Then on "what X is Z's Y?", if not, reply "i do not know". # -- default answer
        "What X is Z's Y?" implies "Does Z have a Y?"; if not, reply "Z does not have a Y".

On "what is the X of Y's Z?", think "what X is Y's Z?".
# = has END =========
# Object Model END.
